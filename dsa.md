- #  List of Fundamental Algorithms and Data Structures to learn :

### Sorting Algorithms:
1. **Bubble Sort:**
   - Simple and inefficient, good for learning the basics.

2. **Insertion Sort:**
   - Efficient for small datasets.

3. **Selection Sort:**
   - Simple and intuitive, but less efficient for large datasets.

4. **Merge Sort:**
   - Efficient, divide-and-conquer approach.

5. **Quick Sort:**
   - Efficient, divide-and-conquer approach with good average-case performance.

### Searching Algorithms:
6. **Linear Search:**
   - Simple search method with linear time complexity.

7. **Binary Search:**
   - Efficient search on sorted arrays, logarithmic time complexity.

### Graph Algorithms:
8. **Depth-First Search (DFS):**
   - Traverses a graph depthwise.

9. **Breadth-First Search (BFS):**
   - Traverses a graph level by level.

10. **Dijkstra's Algorithm:**
    - Finds the shortest path in a weighted graph.

11. **Bellman-Ford Algorithm:**
    - Finds the shortest path in a weighted graph with negative edges.

12. **Kruskal's Algorithm:**
    - Finds the minimum spanning tree in a graph.

13. **Topological Sorting:**
    - Orders vertices in a directed acyclic graph.

### Dynamic Programming:
14. **Fibonacci Sequence (Memoization and Tabulation):**
    - Introduction to dynamic programming.

15. **Longest Common Subsequence:**
    - Dynamic programming for sequence matching.

16. **Knapsack Problem:**
    - Optimal selection of items with limited capacity.

17. **Matrix Chain Multiplication:**
    - Optimal parenthesization of matrix multiplication.

### Divide and Conquer:
18. **Maximum Subarray Sum:**
    - Divide-and-conquer approach for finding the maximum subarray sum.

### Greedy Algorithms:
19. **Activity Selection:**
    - Selecting the maximum number of non-overlapping activities.

20. **Huffman Coding:**
    - Optimal compression algorithm.

### Hashing:
21. **Hash Tables:**
    - Implementing a basic hash table.

22. **Collision Resolution Techniques:**
    - Handling collisions in hash tables (e.g., chaining, open addressing).

### Tree Algorithms:
23. **Binary Trees and Binary Search Trees:**
    - Understanding and implementing basic tree structures.

24. **Tree Traversals (In-order, Pre-order, Post-order):**
    - Understanding different ways to traverse a tree.

25. **LCA (Lowest Common Ancestor):**
    - Finding the lowest common ancestor in a binary tree.

### String Algorithms:
26. **Pattern Matching Algorithms (e.g., KMP, Rabin-Karp):**
    - Efficient methods for finding patterns in strings.

27. **Longest Common Prefix:**
    - Finding the longest common prefix in an array of strings.

### Miscellaneous:
28. **Bit Manipulation:**
    - Understanding and applying bitwise operations.

29. **Union-Find (Disjoint Set Union):**
    - Efficient data structure for tracking disjoint sets.

30. **Trie (Prefix Tree):**
    - Efficient data structure for storing a dynamic set of strings.

### Advanced Topics:
31. **Segment Trees:**
    - Efficient data structure for range queries and updates.

32. **Binary Indexed Tree (Fenwick Tree):**
    - Efficient data structure for range queries.

33. **Suffix Array and Suffix Tree:**
    - Data structures for efficient substring matching.

34. **Graph Algorithms (Advanced):**
    - Floyd-Warshall Algorithm, Johnson's Algorithm, etc.

35. **Advanced Dynamic Programming Problems:**
    - Edit Distance, Subset Sum, etc.

### Problem-Solving Platforms:
36. **Participate in Competitive Programming:**
    - Practice on platforms like Codeforces, LeetCode, HackerRank, etc.

